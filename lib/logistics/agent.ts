import { LogisticsProblem, LogisticsNode, Vehicle } from './types';

interface AgentOptions {
    apiKey?: string;
    provider?: 'gemini' | 'openai' | 'anthropic';
    model?: string;
}

// City coordinates database
const CITY_COORDS: Record<string, { lat: number; lng: number }> = {
    'hamburg': { lat: 53.5511, lng: 9.9937 },
    'berlin': { lat: 52.5200, lng: 13.4050 },
    'munich': { lat: 48.1351, lng: 11.5820 },
    'frankfurt': { lat: 50.1109, lng: 8.6821 },
    'cologne': { lat: 50.9375, lng: 6.9603 },
    'd√ºsseldorf': { lat: 51.2277, lng: 6.7735 },
    'stuttgart': { lat: 48.7758, lng: 9.1829 },
    'dortmund': { lat: 51.5136, lng: 7.4653 },
    'essen': { lat: 51.4556, lng: 7.0116 },
    'leipzig': { lat: 51.3397, lng: 12.3731 },
    'bremen': { lat: 53.0793, lng: 8.8017 },
    'dresden': { lat: 51.0504, lng: 13.7373 },
    'hannover': { lat: 52.3759, lng: 9.7320 },
    'nuremberg': { lat: 49.4521, lng: 11.0767 },
    'london': { lat: 51.5074, lng: -0.1278 },
    'paris': { lat: 48.8566, lng: 2.3522 },
    'amsterdam': { lat: 52.3676, lng: 4.9041 },
    'new york': { lat: 40.7128, lng: -74.0060 },
    'los angeles': { lat: 34.0522, lng: -118.2437 },
    'chicago': { lat: 41.8781, lng: -87.6298 },
};

// System prompt for the Logistics Agent
const LOGISTICS_SYSTEM_PROMPT = `
You are an expert Logistics AI. Parse the user's natural language request into a structured Vehicle Routing Problem (VRP).

Output ONLY a valid JSON object with this exact structure:
{
  "name": "Short problem name",
  "description": "Brief summary",
  "nodes": [
    { "id": "depot_1", "name": "Central Depot", "type": "depot", "location": { "lat": 53.55, "lng": 9.99 } },
    { "id": "cust_1", "name": "Customer 1", "type": "customer", "location": { "lat": 53.56, "lng": 10.01 }, "demand": 2 }
  ],
  "vehicles": [
    { "id": "v_1", "capacity": 15, "startLocation": "depot_1", "color": "#00ff88" }
  ]
}

Rules:
1. Use real city coordinates for the specified city
2. Generate customers with random coordinates spread around the city center (within ~20km radius)
3. Ensure exactly ONE depot at the city center
4. Use vibrant, distinct hex colors for each vehicle: #00ff88, #00ccff, #ff00cc, #ffcc00, #ff3333, #a855f7
5. Set realistic capacity (10-25) per vehicle
6. Set demand (1-5) per customer
7. If number of stops/locations not specified, default to 20
8. If number of vehicles/trucks not specified, default to 4
`;

export async function parseLogisticsRequest(
    query: string,
    options: AgentOptions = {}
): Promise<LogisticsProblem> {
    const { apiKey, provider = 'gemini', model = 'gemini-2.0-flash-exp' } = options;

    if (!apiKey) {
        console.log("No API key provided, using intelligent mock for:", query);
        return generateMockProblem(query);
    }

    try {
        const response = await fetch(
            `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [
                        { role: 'user', parts: [{ text: LOGISTICS_SYSTEM_PROMPT + "\n\nUser request: " + query }] }
                    ],
                    generationConfig: {
                        responseMimeType: "application/json",
                        temperature: 0.7
                    }
                })
            }
        );

        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }

        const data = await response.json();
        const jsonText = data.candidates?.[0]?.content?.parts?.[0]?.text;

        if (!jsonText) {
            throw new Error("No content returned from AI");
        }

        const parsed = JSON.parse(jsonText);

        // Validate structure
        if (!parsed.nodes || !parsed.vehicles || parsed.nodes.length === 0) {
            throw new Error("Invalid problem structure");
        }

        return {
            id: crypto.randomUUID(),
            name: parsed.name || 'AI Generated Problem',
            description: parsed.description || 'Generated by Gemini AI',
            nodes: parsed.nodes,
            vehicles: parsed.vehicles
        };

    } catch (e) {
        console.error("AI Parse failed, falling back to mock:", e);
        return generateMockProblem(query);
    }
}

// Intelligent mock generator that parses the query
function generateMockProblem(query: string): LogisticsProblem {
    const lower = query.toLowerCase();

    // Parse numbers
    let numCustomers = 20;
    const stopPatterns = [
        /(\d+)\s*(stop|customer|location|point|destination|package|deliver)/i,
        /deliver(?:ing)?\s+to\s+(\d+)/i,
        /(\d+)\s+(?:different\s+)?place/i
    ];
    for (const pattern of stopPatterns) {
        const match = lower.match(pattern);
        if (match) {
            numCustomers = Math.min(100, Math.max(5, parseInt(match[1])));
            break;
        }
    }

    let numVehicles = 4;
    const vehiclePatterns = [
        /(\d+)\s*(vehicle|truck|van|car|fleet|driver)/i,
        /fleet\s+of\s+(\d+)/i
    ];
    for (const pattern of vehiclePatterns) {
        const match = lower.match(pattern);
        if (match) {
            numVehicles = Math.min(20, Math.max(1, parseInt(match[1])));
            break;
        }
    }

    // Detect city
    let cityCenter = CITY_COORDS['hamburg']; // Default
    let cityName = 'Hamburg';

    for (const [city, coords] of Object.entries(CITY_COORDS)) {
        if (lower.includes(city)) {
            cityCenter = coords;
            cityName = city.charAt(0).toUpperCase() + city.slice(1);
            break;
        }
    }

    const nodes: LogisticsNode[] = [];

    // Central Depot
    nodes.push({
        id: 'depot_1',
        name: `${cityName} Central Depot`,
        type: 'depot',
        location: { lat: cityCenter.lat, lng: cityCenter.lng }
    });

    // Generate customers in realistic clusters
    for (let i = 0; i < numCustomers; i++) {
        // Create some clustering effect
        const cluster = Math.floor(Math.random() * 5);
        const clusterOffset = {
            lat: (cluster % 3 - 1) * 0.05,
            lng: (Math.floor(cluster / 3) - 0.5) * 0.1
        };

        const dLat = (Math.random() - 0.5) * 0.15 + clusterOffset.lat;
        const dLng = (Math.random() - 0.5) * 0.3 + clusterOffset.lng;

        nodes.push({
            id: `cust_${i}`,
            name: `Delivery ${i + 1}`,
            type: 'customer',
            location: {
                lat: cityCenter.lat + dLat,
                lng: cityCenter.lng + dLng
            },
            demand: Math.floor(Math.random() * 4) + 1
        });
    }

    const vehicles: Vehicle[] = [];
    const colors = ['#00ff88', '#00ccff', '#ff00cc', '#ffcc00', '#ff3333', '#a855f7', '#ec4899', '#06b6d4', '#8b5cf6', '#f59e0b'];

    for (let i = 0; i < numVehicles; i++) {
        vehicles.push({
            id: `vehicle_${i}`,
            capacity: 15 + Math.floor(Math.random() * 10),
            startLocation: 'depot_1',
            color: colors[i % colors.length]
        });
    }

    return {
        id: crypto.randomUUID(),
        name: `${cityName} Logistics Optimization`,
        description: `Optimizing ${numVehicles} vehicle routes for ${numCustomers} delivery stops in ${cityName}`,
        nodes,
        vehicles
    };
}
